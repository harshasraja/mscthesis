%à¤¬
\chapter{Experimental Design}

\todo{Check number of enrolments, introduce all metadata, and retrieve 
details of cassandra cluster from my computer}

The implementation of the four solutions  introduces referential imtegrity
constraints and validations in Cassandra, which did not previously exist in this
\ac{DBMS}. In order to evaluate the performance of the four solutions when
deployed on Cassandra, experiments were conducted by implementing the
experimental \ac{API}. The goal of the experiments were to determine how each
solution affected Cassandra in its performance.

 In the experimnets, the experimental \ac{API} was loaded with entities
 belonging to a prototype keyspace  on which \ac{CRUD} operations were performed
 that triggered the validation. Each \ac{CRUD} operation caused the \ac{API} to
 interact with the Cassandra cluster, which was  a homogeneous group of multiple
 nodes having similar characteristics and configurations. The performance of the
 soulitions and Cassandra during these experiments  were measured based on
 certain performance indicators, namely, response time and throughput.

The details of the experimental setup are described in the following sections.
Section~\ref{sexp:BenchmarkKeyspace} describes the protoype keyspace used for
the xperiments. Section~\ref{sexp:CassandraCluster} prvides the details of the
nodes used in the Cassandra cluster. Section~\ref{sexp:ExperimentalSetup}
describes the details of the experimental setup.
Section~\ref{sexp:PerformanceIndicators} describe the perfromance indicators
that are considered for measuring the results fromt he experiments.
Section~\ref{sexp:Summary} presents a summary of the chapter.


\section{Benchmark keyspace} \label{sexp:BenchmarkKeyspace}
% In order to asses the performance of Cassandra when the four solutions are
% executed,
In the experiments, the experimental \ac{API} is implemented by loading
entitites belonging to a prototype keyspace designed for these experiments. The
prototype keyspace is modelled on a University keyspace that stores the details
of students and courses along with the enrolment details of the students.The
class diagram for the University keyspace is shown in
Figure~\ref{fexp:ClassDiagram}. The entities are saved as the following column
families in Cassandra.

	\begin{itemize}
	  \item \texttt{Student} to store the student attributes \texttt{StudentId}
	  (primary key), \texttt{FirstName}, \texttt{LastName}, \texttt{Email} and
	  \texttt{Age}.
	  \item \texttt{Course} to store course information with the attributes
	  \texttt{CourseId} (primary key), \texttt{CourseName}, \texttt{Trimester},
	  \texttt{Level} and \texttt{Year}.
	  \item \texttt{Enrolment} to preserve the relationship between students and
	  the courses they enrol into. The attributes for \texttt{Enrolment} are
	  \texttt{RowId} (primary key), \texttt{StudentId} and \texttt{CourseId}. The
	  \texttt{StudentId} and \texttt{CourseId} are foreign keys.
	\end{itemize}
	
	\begin{figure}[h] \centering
		\includegraphics[width=1\textwidth]{./figure/Solutions/classdiagram-experimental.png}
		\caption{Class Diagram for University}\label{fexp:ClassDiagram}
	\end{figure} 

The constraints for the keyspace are stored in the \texttt{Metadata} entity
class.These constraints are the \ac{PK} and \ac{FK} constraints applicable on each of
the column families in this keyspace. The list of constraints are the same for
all the solutions  and are shown in Table~\ref{texp:ListConstraints}.


\begin{table}[h] \label{texp:ListConstraints}
\centering
\caption{Metadata}	
	\newcolumntype{C}{@{\hspace{2.5pt}}>{\scriptsize}c@{\hspace{2.5pt}}}
	\begin{tabular}{CCC CCC CC}
		\toprule
		\bfseries ConstraintName & \bfseries Keyspace & \bfseries ConstraintType &
		\bfseries ColumnFamily & \bfseries RKeyspace & \bfseries RConstraintName &
		\bfseries RColumn & \bfseries DeleteRule\\
		\midrule
		CONST100 & University & P & Student & University & & StudentId &\\
		\rc CONST200 & University & P & Course & University & & CourseId &\\
		CONST300 & University & P & Enrolment & University & & RowId &\\
% 		\hline
% 		\hline
		\rc CONST400 & University & R & Enrolment & University & CONST100 & StudentId
		& CASCADE\\
		CONST500 & University & R & Enrolment & University & CONST200 & CourseId &
		NODELETE\\
		\rc CONST600 & University & F & Course & University & CONST500 & CourseId &
		NODELETE\\
		CONST700 & University & F & Student & University & CONST400 & StudentId &
		CASCADE\\
		\bottomrule
	\end{tabular}
\end{table}

The \texttt{ValidationHandler} in each solution checks these constraints to
validate referential integrity within this keyspace. The entities are loaded
generically by the \texttt{EntityManager} for each solution. 
% In the experiment,
% the number of entities inserted for each column family in all the solutions are
% shown in Table~\ref{texp:EntityList}. 
% 	
% 	\begin{table} \label{texp:EntityList}
% 	\centering
% 	\newcolumntype{C} {@{\hspace{2.5pt}}>{\scriptsize}c@{\hspace{2.5pt}}}
% 		\begin{tabular}{CC}
% 			
% 			\toprule
% 			\bfseries ColumnFamily & \bfseries No. of Entities \\
% 			\midrule
% 			Student & 1000 \\
% 			\rc Course & 1000 \\
% 			Enrolment & 10000  \\
% 	% 		\hline
% 	% 		\hline
% 			
% 			\bottomrule
% 		\end{tabular}
% 	\end{table}


\section{Cassandra cluster} \label{sexp:CassandraCluster}

The environment to deploy cassandra is  an homogeneous cluster conformed by 10
nodes. That is, all 10 nodes have the same characteristics in software and
hardware. These nodes emulate a cloud environment in which each node runs
Cassandraand saves the data on te local disks of the machines. The
characteristics of these nodes are:

	\begin{table} \label{texp:Nodeconfig}
	\centering
	\newcolumntype{C} {@{\hspace{2.5pt}}>{\scriptsize}c@{\hspace{2.5pt}}}
		\begin{tabular}{CC}
			\toprule
			\bfseries System configurations\\
			\midrule
			Linux kernel version & Linux 3.2.4-1-ARCH i686 \\
			\rc CPU & Intel(R) Core(TM)2 Duo CPU     E8400  @ 3.00GHz \\
			CPU cores & 4  \\
			\bottomrule
		\end{tabular}
	\end{table}



Linux kernel version: Linux 3.2.4-1-ARCH i686

CPU: Intel(R) Core(TM)2 Duo CPU     E8400  @ 3.00GHz

CPU cores: 4


%             total       used       free     shared    buffers     cached
% Mem:          3195       2941        254          0        212       1493

Cassandra configurations:

Version: 0.8.4

Hector Version: 0.8.0-2

Replication strategy:

Partitioner used: Random Partitioner which distrbutes rows in a cluster evenly.
This is the default configuration setting when Cassandra is installed.

The configurations on all the modes are set to the default values in the yaml
configuration file.

The first node is started as a seed node and has the Auto Bootstrap option set
to true. This allows other nodes with this ndoe as its seed to migrate data from
the seed node while data partitioning. For the rest of the nodes tihs options is
set to false.Hinted Handoff is enabled on all nodes.

\begin{itemize}
  \item Hardware
  \item Software
\end{itemize}




\include{chapter/Experimental-setup}



\include{chapter/Experimental-PerformanceMeasures}

\section{Summary} \label{sexp:Summary} 

This chapter  presented the experimental design to evaluate the performance of
each  solution and the experimental \ac{API} itself using th prototype keyspace
that is used as an example across this thesis. The experimental design involves
assessing the performance of the CRUD operations on the different solutions
proposed for referential integrity.
The analysis of results is to be based on response time and throughput, two
performance indicators that serve as guidelines for assessing the tradeoffs
between the different solutions proposed.
	
	
The next chapter presents the results and their discussions of the experimental
design presented in this chapter
 






