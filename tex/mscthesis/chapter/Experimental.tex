%à¤¬
\chapter{Experimental Design}

\todo{Check number of enrolments, introduce all metadata, and retrieve 
details of cassandra cluster from my computer}

The implementation of the four solutions  introduces referential integrity
constraints and validations in Cassandra, which are 
not provided by this \ac{DBMS} at the moment of writing. In order to evaluate
 the performance of these four solutions, experiments are 
  conducted by using the implemented \ac{API} described in
  Section~\todo{Section}.   The goal of the experiments is to determine how
  each solution affects the performance of  Cassandra in \ac{CRUD}
  operations, especifically in those where referential integrity validations are
  triggered (namely Create, Update and Delete).

The experimentation is performed on the example application presented across
chapters: the University keyspace. In such an application, different constraints
are added and allow to test the performance under such different application
requirements. The performance of the  solutions provided for ensuring
referential integrity  is measured based on response time and throughput.

This chapter is structured as follows.
Section~\ref{sexp:BenchmarkKeyspace} describes the example application 
used for the experiments. Section~\ref{sexp:CassandraCluster} provides the
details of the nodes used in the Cassandra cluster. Section~\ref{sexp:ExperimentalSetup}
describes the experimental setup to evaluate the performance of the solutions.
Section~\ref{sexp:PerformanceIndicators} presents the performance indicators
 considered for measuring the results from the experiments. Finally,
Section~\ref{sexp:Summary} presents a summary of the chapter.


\section{Example application} \label{sexp:BenchmarkKeyspace}
% In order to asses the performance of Cassandra when the four solutions are
% executed,
% In the experiments, the experimental \ac{API} is implemented by loading
% entitites belonging to a prototype keyspace designed for these experiments. The
% prototype keyspace is modelled on a University keyspace that stores the details
% of students and courses along with the enrolment details of the students.The
% class diagram for the University keyspace is shown in
% Figure~\ref{fexp:ClassDiagram}. The entities are saved as the following column
% families in Cassandra.

The  \ac{API} designed and implemented in the previous chapters is validated and
tested by performing \ac{CRUD} operations on an example application
especifically designed for this purpose. This application has been referred to
as the \texttt{University} keyspace in previous chapters, and it contains
different constraints in order to  assess the performance of the \ac{API} and
the solutions on each of them. This application stores the details of students and
 courses along with the enrolment details of the students. The class diagram for
 the University keyspace is shown in Figure~\ref{fexp:ClassDiagram}, and each
 entity is saved into its respective column family in a Cassandra cluster.

	\begin{itemize}
	  \item \texttt{Student} stores the  following attributes of students:
	   \texttt{StudentId} (primary key), \texttt{FirstName}, \texttt{LastName},
	  \texttt{Email} and \texttt{Age}.
	  \item \texttt{Course} stores  the following  attributes of courses:
	  \texttt{CourseId} (primary key), \texttt{CourseName}, \texttt{Trimester},
	  \texttt{Level} and \texttt{Year}.
	  \item \texttt{Enrolment} stores the  relationship between
	  students and courses, that is, it stores the courses each student is enrolled
	  into.  The attributes for \texttt{Enrolment} are \texttt{RowId} (primary
	  key), \texttt{StudentId} and \texttt{CourseId}, where \texttt{StudentId}
	  and \texttt{CourseId} are foreign keys.
	\end{itemize}
	
	\begin{figure}[h] \centering
		\includegraphics[width=1\textwidth]{./figure/Solutions/classdiagram-experimental.png}
		\caption{Class Diagram for University}\label{fexp:ClassDiagram}
	\end{figure} 

% The constraints for the keyspace are stored in  a  \texttt{Metadata} entity
% class.These constraints are the \ac{PK} and \ac{FK} constraints applicable on each of
% the column families in this keyspace. The list of constraints are the same for
% all the solutions  and are shown in Table~\ref{texp:ListConstraints}.

The list of constraints created for the University keyspace can be seen in
Table~\ref{texp:ListConstraints}. \texttt{CONST100... CONST700} \todo{explain
the purpose of each of them}.


\begin{table}[h] \label{texp:ListConstraints}
\centering
\caption{Metadata}	
	\newcolumntype{C}{@{\hspace{2.5pt}}>{\scriptsize}c@{\hspace{2.5pt}}}
	\begin{tabular}{CCC CCC CC}
		\toprule
		\bfseries ConstraintName & \bfseries Keyspace & \bfseries ConstraintType &
		\bfseries ColumnFamily & \bfseries RKeyspace & \bfseries RConstraintName &
		\bfseries RColumn & \bfseries DeleteRule\\
		\midrule
		CONST100 & University & P & Student & University & & StudentId &\\
		\rc CONST200 & University & P & Course & University & & CourseId &\\
		CONST300 & University & P & Enrolment & University & & RowId &\\
% 		\hline
% 		\hline
		\rc CONST400 & University & R & Enrolment & University & CONST100 & StudentId
		& CASCADE\\
		CONST500 & University & R & Enrolment & University & CONST200 & CourseId &
		NODELETE\\
		\rc CONST600 & University & F & Course & University & CONST500 & CourseId &
		NODELETE\\
		CONST700 & University & F & Student & University & CONST400 & StudentId &
		CASCADE\\
		\bottomrule
	\end{tabular}
\end{table}

% The \texttt{ValidationHandler} in each solution checks these constraints to
% validate referential integrity within this keyspace. The entities are loaded
% generically by the \texttt{EntityManager} for each solution. 
% In the experiment,
% the number of entities inserted for each column family in all the solutions are
% shown in Table~\ref{texp:EntityList}. 
% 	
% 	\begin{table} \label{texp:EntityList}
% 	\centering
% 	\newcolumntype{C} {@{\hspace{2.5pt}}>{\scriptsize}c@{\hspace{2.5pt}}}
% 		\begin{tabular}{CC}
% 			
% 			\toprule
% 			\bfseries ColumnFamily & \bfseries No. of Entities \\
% 			\midrule
% 			Student & 1000 \\
% 			\rc Course & 1000 \\
% 			Enrolment & 10000  \\
% 	% 		\hline
% 	% 		\hline
% 			
% 			\bottomrule
% 		\end{tabular}
% 	\end{table}


\section{Cassandra cluster} \label{sexp:CassandraCluster}
Cassandra is deployed in an homogeneous cluster conformed by 10 nodes. That is,
 all 10 nodes have the same characteristics in software and hardware. These
 nodes emulate a cloud environment in which each node saves
 the data on the local disks of the machines. Notice that, for Solution~4,  an
 additional node is used to emulate an external cluster dedicated to provide
 metadata of the entities upon request.
 The characteristics of these nodes are:


\begin{itemize}
  \item Hardware: \todo{Look on internet the specs of the model}
  	\begin{itemize}
  	  
  	 \end{itemize}
  \item Software: 
  \begin{itemize}
    \item Operating system
    \item Java JDK
    \item Cassandra version 0. 8. 4 
    \item Hector version 0. 8. 0-2.
  \end{itemize}
\end{itemize}


 


% 	\begin{table}[H] \label{texp:Nodeconfig}
% 	\centering
% 	\newcolumntype{C} {@{\hspace{2.5pt}}>{\scriptsize}c@{\hspace{2.5pt}}}
% 		\begin{tabular}{CC}
% 			\toprule
% % 			\bfseries System configurations\\
% 			
% 			Linux kernel version & Linux 3. 2. 4-1-ARCH i686 (62-bit)\\
% 			\rc CPU & Intel(R) Core(TM)2 Duo CPU     E8400  @ 3. 00GHz \\
% 			CPU cores & 4  \\
% 			\rc Network Card & 3 Gigabit \\
% 			Allocated memory & ?? \\
% 			\bottomrule
% 		\end{tabular}
% 	\end{table}

The nodes used in the cluster are part of the \ac{ECS} grid system of
\ac{VUW}. Notice that, such a cluster is not a controlled environment and it is
not possible to use it as  a dedicated cluster as it is also used for other grid
jobs as well as students. Nonetheless, the experiments can be performed over
night during weekends when the external usage of the nodes is minimal.

Some values in the configuration files on each node are changed before starting
the cluster of nodes.  For every node,  the \texttt{listen\_address} and
\texttt{rpc\_address} are set to the hostname.  The nodes are added to the
cluster in a sequential order.  One of the nodes is chosen as the first node and
is made the host node (a.k.a. seed node).  
This node becomes the contact point
for other nodes that join the cluster \todo{? is this true? if it is a ring
topology, then it doesnt sound right, especially after saying later that it
does not contact any other node}.
The list of seed nodes for any given node is specified in a configuration file under the \texttt{seeds} option.  For the
 first node,  this option is set to its loopback address \texttt{127.0.0.1}
 to indicate that it does not contact any other node to join the cluster.  For
 nodes that are not seed nodes, this option contains the hostnames that it can
contact to learn about the cluster.  In the experiments,  except for the first
node, the remaining 9 nodes have two neighboring hosts  as seeds. 

The seed node has its \texttt{auto\_bootstrap} option set to \texttt{true} to
allow other nodes to migrate data from it when data is partitioned or when other
nodes join the cluster.  For nodes that are not seed nodes,  this option is set
to \texttt{false}.  This is because all the nodes are started prior to the 
experiments and do not have data to partition yet. 
 
% The Random Partitioner distributes rows in a cluster evenly and is the
% default configuration setting when Cassandra is installed. 
All the remaining
settings in the Cassandra configuration file are set to the  default values
for all the nodes.  The directories for saving the data,  commit logs and saved
caches are saved on the local disk of each node in its temporary
folder folder (\texttt{/local/tmp}).

% As for Solution~4, an additional node is created to serve as an external
% cluster. 
%  Note that for the Metadata cluster used in Solution~4,  the  cluster
% name is \texttt{MetadataCluster}and the ports for Thrift clients  and TCP sessions are
% changed.  

% Once the cluster is started,  the experiments are initiated and the time taken 
% operations are measured based on performance metrics.  The metrics used for the experiments
% are described in the following section. 


\include{chapter/Experimental-setup}



\include{chapter/Experimental-PerformanceMeasures}

\section{Summary} \label{sexp:Summary} 

This chapter  presented the experimental design to evaluate the performance of
each  solution and the experimental \ac{API} itself using the prototype keyspace
that is used as an example across this thesis.  The experimental design involves
assessing the performance of the CRUD operations on the different solutions
proposed for referential integrity. 
The analysis of results is to be based on response time and throughput,  two
performance indicators that serve as guidelines for assessing the trade-offs
between the different solutions proposed. 
	
	
The next chapter presents the results and their discussions of the experimental
design presented in this chapter
 






